Пакети, змінні та функції.
Вивчіть базові компоненти будь-якої Go програми.

Автори Go
http://golang.org

* Пакети

Кожна програма на Go складається з пакетів.

Програми починають виконання з пакету `main`.

Дана програма використовує пакети зі шляхом імпорту `"fmt"` та `"math/rand"`.

За умовою, назва пакету збігається з останнім елементом шляху імпорту. Наприклад, пакет `"math/rand"` містить файли, що починаються з інструкції `package`rand`.

#appengine: *Примітка:* середовище в якому виконуються програми є
#appengine: визначеним, тобто `rand.Intn` завжди повертатиме одне й те саме число.
#appengine:
#appengine: (Щоб отримати інший результат, задайте початкове «зерно» генератора чисел; див. [[http://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].)

.play basics/packages.go

* Імпорт

Даний код об’єднує імпорт в дужки, так звана «складена» інструкція імпорту. 

Ви також можете писати декілька інструкцій імпорту, ось так:

	import "fmt"
	import "math"

Але хорошим стилем є використання складеної інструкції імпорту.

.play basics/imports.go

* Експортовані назви

Після імпортування пакети ви можете звертатися до імен, як він експортує.

В Go, ім’я експортується, якщо воно починається з великої літери.

`Foo` експортується, так само як `FOO`. Ім’я `foo` не експортується.

Виконайте код. Потім переіменуйте `math.pi` на `math.Pi` та спробуйте знову.

.play basics/exported-names.go

* Функції

Функція може приймати нуль або більше аргументів.

У даному прикладі, `add` приймає два параметри типу `int`.

Зверніть увагу, що тип знаходиться _після_ імені змінної.

(Більше про типи та чому вони виглядають саме так, дивіться у [[http://blog.golang.org/gos-declaration-syntax][статті про синтаксис декларацій Go]].)

.play basics/functions.go

* Functions continued

When two or more consecutive named function parameters share a type, you can omit the type from all but the last.

In this example, we shortened

	x int, y int

to

	x, y int

.play basics/functions-continued.go

* Multiple results

A function can return any number of results.

The `swap` function returns two strings.

.play basics/multiple-results.go

* Named return values

Go's return values may be named and act just like variables.

These names should be used to document the meaning of the return values.

A `return` statement without arguments returns the current values of the results. This is known as a "naked" return.

Naked return statements should be used only in short functions, as with the example shown here. They can harm readability in longer functions.

.play basics/named-results.go

* Variables

The `var` statement declares a list of variables; as in function argument lists, the type is last.

A `var` statement can be at package or function level. We see both in this example.

.play basics/variables.go

* Variables with initializers

A var declaration can include initializers, one per variable.

If an initializer is present, the type can be omitted; the variable will take the type of the initializer.

.play basics/variables-with-initializers.go

* Short variable declarations

Inside a function, the `:=` short assignment statement can be used in place of a `var` declaration with implicit type.

Outside a function, every statement begins with a keyword (`var`, `func`, and so on) and so the `:=` construct is not available.

.play basics/short-variable-declarations.go

* Basic types

Go's basic types are

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // alias for uint8

	rune // alias for int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128

The example shows variables of several types,
and also that variable declarations may be "factored" into blocks,
as with import statements.

.play basics/basic-types.go

* Zero values

Variables declared without an explicit initial value are given their
_zero_value_.

The zero value is:

- `0` for numeric types,
- `false` the boolean type, and
- `""` (the empty string) for strings.

.play basics/zero.go

* Type conversions

The expression `T(v)` converts the value `v` to the type `T`.

Some numeric conversions:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

Or, put more simply:

	i := 42
	f := float64(i)
	u := uint(f)

Unlike in C, in Go assignment between items of different type requires an
explicit conversion.
Try removing the `float64` or `int` conversions in the example and see what happens.

.play basics/type-conversions.go

* Type inference

When declaring a variable without specifying its type (using `var` without a type or the `:=` syntax), the variable's type is _inferred_ from the value on the right hand side.

When the right hand side of the declaration is typed, the new variable is of that same type:

	var i int
	j := i // j is an int

But when the right hand side contains an untyped numeric constant, the new variable may be an `int`, `float64`, or `complex128` depending on the precision of the constant:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

Try changing the initial value of `v` in the example code and observe how its type is affected.

.play basics/type-inference.go

* Constants

Constants are declared like variables, but with the `const` keyword.

Constants can be character, string, boolean, or numeric values.

Constants cannot be declared using the `:=` syntax.

.play basics/constants.go

* Numeric Constants

Numeric constants are high-precision _values_.

An untyped constant takes the type needed by its context.

Try printing `needInt(Big)` too.

.play basics/numeric-constants.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
