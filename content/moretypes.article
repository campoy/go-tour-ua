Більше типів: структури, вирізки та словники.
Навчіться описувати типи на основі існуючих: це заняття охоплює структури, масиви, вирізки та словники.

Автори Go
http://golang.org

* Вказівники

В Go є вказівники.
Вказівник містить адресу пам’яті для змінної.

Тип `*T` — вказіник на значення з типом `T`. Його нульове значення це `nil`.

	var p *int

Оператор `&` генерує вказівник на свій операнд.

	i := 42
	p = &i

Оператор `*` визначає залежне значення за вказівником.

	fmt.Println(*p) // прочитати i через вказівник p
	*p = 21         // задати i через вказівник p

Це відомо як "розіменування" чи "присвоювання".

На відміну від C, в Go немає адресної арифметики.

.play moretypes/pointers.go

* Структури

`struct` — це колекція полів.

(А оголошення `type` робить те, що ви могли б очікувати.)

.play moretypes/structs.go

* Поля структури

До полів структури звертаються через крапку.

.play moretypes/struct-fields.go

* Вказівники на структури

До полів структури можна звертатися через вказівник на структуру.

Непряма адресація через вказівник є прозорою.

.play moretypes/struct-pointers.go

* Літерали структур

Літерал структури визначає новостворену структуру через перелік значень її полів.

Ви можете перелічити тільки окремий набір полів за допомогою синтаксису `Name:` (порядок іменованих полів неважливий).

Спеціальний префікс `&` повертає вказівник на значення структури.

.play moretypes/struct-literals.go

* Масиви

Тип `[n]T` — масив з `n` значень типу `T`.

Вираз

	var a [10]int

оголошує змінну `a` масивом з десяти цілих.

Розмір масиву є частиною його типу, тож масиви не можуть змінювати розмір.
Це видається обмеженням, але не хвилюйтесь;
Go забезпечує зручний спосіб роботи з масивами.

.play moretypes/array.go

* Вирізки

Вирізка вказує на масив значень, але також включає довжину.

`[]T` — це вирізка з елементами типу `T`.

.play moretypes/slices.go

* Вирізки вирізок

Вирізки можуть бути пере-різані, що створює нове значення вирізки, яке вказує на той самий масив.

Вираз

	s[lo:hi]

визначає вирізку елементів з `lo` до `hi-1`, включно. Отже

	s[lo:lo]

порожня, а

	s[lo:lo+1]

містить один елемент.

.play moretypes/slicing-slices.go

* Створення вирізок

Вирізки створюються функцією `make`. Вона працює через створення обнуленного масиву та повертає вирізку, що посилається на цей масив:

	a := make([]int, 5)  // len(a)=5

Щоб задати ємність, передайте третій параметер для `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go

* Nil вирізки

Нульнове значення вирізки — це `nil`.

Nil вирізка має довжину та ємність рівні 0.

.play moretypes/nil-slices.go

* Додавання елементів до вирізки

Поширеним є додавання до вирізки нових елементів, тож Go забезпечує вбудовану
функцію `append`. [[http://golang.org/pkg/builtin/#append][Документація]]
вбудованого пакету описує `append`.

	func append(s []T, vs ...T) []T

Перший параметр `s` в `append` — це вирізка типу `T`, а інші є
значеннями `T`, що додаються до вирізки.

Значення результату `append` — це вирізка, що містить всі елементи
початкової вирізки плюс надані значення.

Якщо прихований за `s` масив є занадто малим, щоб вмістити всі надані значення,
то буде виділений більший масив. Повернена вирізка буде вказувати на новий масив.

(Щоб дізнатися про вирізки більше, прочитайте статтю [[http://blog.golang.org/go-slices-usage-and-internals][Вирізки: вживання та внутрішня побудова]].)

.play moretypes/append.go

* Range

Різновид `range` циклу `for` повторюється для вирізки або словника.

.play moretypes/range.go

* Range, продовження

Ви можете пропустити позицію або значення, призначаючи `_`.

Якщо потрібна тільки позиція, то ", value" можна відкинути зовсім.

.play moretypes/range-continued.go

* Вправа: Вирізки

Implement `Pic`. It should return a slice of length `dy`, each element of which is a slice of `dx` 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.

The choice of image is up to you. Interesting functions include `(x+y)/2`, `x*y`, and `x^y`.

(You need to use a loop to allocate each `[]uint8` inside the `[][]uint8`.)

(Use `uint8(intValue)` to convert between types.)

.play moretypes/exercise-slices.go

* Maps

A map maps keys to values.

Maps must be created with `make` (not `new`) before use; the `nil` map is empty and cannot be assigned to.

.play moretypes/maps.go

* Map literals

Map literals are like struct literals, but the keys are required.

.play moretypes/map-literals.go

* Map literals continued

If the top-level type is just a type name, you can omit it from the elements of the literal.

.play moretypes/map-literals-continued.go

* Mutating Maps

Insert or update an element in map `m`:

	m[key] = elem

Retrieve an element:

	elem = m[key]

Delete an element:

	delete(m, key)

Test that a key is present with a two-value assignment:

	elem, ok = m[key]

If `key` is in `m`, `ok` is `true`. If not, `ok` is `false` and `elem` is the zero value for the map's element type.

Similarly, when reading from a map if the key is not present the result is the zero value for the map's element type.

.play moretypes/mutating-maps.go

* Exercise: Maps

Implement `WordCount`.  It should return a map of the counts of each “word” in the string `s`. The `wc.Test` function runs a test suite against the provided function and prints success or failure.

You might find [[http://golang.org/pkg/strings/#Fields][strings.Fields]] helpful.

.play moretypes/exercise-maps.go

* Function values

Functions are values too.

.play moretypes/function-values.go

* Function closures

Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.

For example, the `adder` function returns a closure. Each closure is bound to its own `sum` variable.

.play moretypes/function-closures.go

* Exercise: Fibonacci closure

Let's have some fun with functions.

Implement a `fibonacci` function that returns a function (a closure) that returns successive fibonacci numbers.

.play moretypes/exercise-fibonacci-closure.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
